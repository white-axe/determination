# Determination - Deterministic rendering environment for white-axe's music
# Copyright (C) 2024 Liu Hao <whiteaxe@tuta.io>
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This patch does several things to the Carla source code:
#   * Forces all of Carla's libraries to be built as static libraries.
#   * The JACK engine exposes extra functions:
#     `determination_get_jack_client` and `determination_set_process_callback`.
#   * The JACK engine's host JACK client now has two audio input ports called
#     "RecorderL" and "RecorderR", and connections to the "Audio Output" JACK
#     client are converted to be connected to these input ports instead of to
#     the system playback audio ports so that we can record the audio that goes
#     to "Audio Output".
#   * Audio plugins do not process unless the JACK transport is rolling. Many
#     synthesizers and effects plugins produce slightly different outputs
#     depending on how many audio samples they've received since initialization,
#     e.g. because they use LFO. This patch helps by ensuring that the number of
#     audio samples received by a certain timecode is consistent each time,
#     avoiding an entire class of nondeterminisms!

--- a/cmake/CMakeLists.txt
+++ b/cmake/CMakeLists.txt
@@ -61,11 +61,11 @@ if(${CARLA_BUILD_FRAMEWORKS} AND NOT APPLE)
   mark_as_advanced(CARLA_BUILD_FRAMEWORKS)
 endif()
 
-if(${CARLA_BUILD_STATIC})
+#if(${CARLA_BUILD_STATIC})
   set(CARLA_LIB_TYPE STATIC)
-else()
-  set(CARLA_LIB_TYPE SHARED)
-endif()
+#else()
+#  set(CARLA_LIB_TYPE SHARED)
+#endif()
 
 if(${CARLA_BUILD_FRAMEWORKS})
   execute_process(COMMAND date -u +%y%m%d%H%M%S OUTPUT_VARIABLE CARLA_DATE OUTPUT_STRIP_TRAILING_WHITESPACE)
--- a/source/backend/engine/CarlaEngine.cpp
+++ b/source/backend/engine/CarlaEngine.cpp
@@ -3528,11 +3528,11 @@ bool CarlaEngine::loadProjectInternal(water::XmlDocument& xmlDoc, const bool alw
                         water::String externalPort = targetPort.trimCharactersAtStart("Audio Output:");
 
                         /**/ if (externalPort == "Left")
-                            externalPort = "system:playback_1";
+                            externalPort = water::String(getName()) + ":RecorderL"; // Convert "Audio Output:Left" to RecorderL
                         else if (externalPort == "Right")
-                            externalPort = "system:playback_2";
-                        else
-                            externalPort = "system:playback_ " + externalPort.trimCharactersAtStart("Playback ");
+                            externalPort = water::String(getName()) + ":RecorderR"; // Convert "Audio Output:Right" to RecorderR
+                        //else
+                        //    externalPort = "system:playback_ " + externalPort.trimCharactersAtStart("Playback ");
 
                         carla_stdout("Converted port name '%s' to '%s' for this session",
                                      targetPort.toRawUTF8(), externalPort.toRawUTF8());
--- a/source/backend/engine/CarlaEngineJack.cpp
+++ b/source/backend/engine/CarlaEngineJack.cpp
@@ -1324,7 +1324,7 @@ class CarlaEngineJack : public CarlaEngine
                       , private CarlaThread
 #endif
 {
-public:
+public: jack_client_t *determination_get_jack_client() { return fClient; } void determination_set_process_callback(JackProcessCallback callback, void *arg) { fCallback = callback; fCallbackArg = arg; }
     CarlaEngineJack()
         : CarlaEngine(),
 #ifndef BUILD_BRIDGE
@@ -1503,7 +1503,7 @@ public:
         }
 
         fClientName = jackClientName;
-
+        jackbridge_port_register(fClient, "RecorderL", JACK_DEFAULT_AUDIO_TYPE, JackPortIsInput | JackPortIsTerminal, 0); jackbridge_port_register(fClient, "RecorderR", JACK_DEFAULT_AUDIO_TYPE, JackPortIsInput | JackPortIsTerminal, 0); // Create the RecorderL and RecorderR audio ports
         const EngineOptions& opts(pData->options);
 
         pData->bufferSize = jackbridge_get_buffer_size(fClient);
@@ -2841,8 +2841,8 @@ protected:
         offlineModeChanged(isFreewheel);
     }
 
-    void handleJackProcessCallback(const uint32_t nframes)
-    {
+    void handleJackProcessCallback(const uint32_t nframes) {
+        if (fCallback != NULL) fCallback(nframes, fCallbackArg); // Call the callback set by `determination_set_process_callback()`
         const PendingRtEventsRunner prt(this, nframes);
 
         CARLA_SAFE_ASSERT_INT2_RETURN(nframes == pData->bufferSize, nframes, pData->bufferSize,);
@@ -3570,7 +3570,7 @@ private:
     bool fExternalPatchbayHost;
     bool fExternalPatchbayOsc;
     bool fFreewheel;
-
+    JackProcessCallback fCallback; void *fCallbackArg;
     CarlaString fClientName;
     CarlaRecursiveMutex fThreadSafeMetadataMutex;
 
@@ -4409,7 +4409,7 @@ private:
 
         CarlaEngineJack* const engine((CarlaEngineJack*)plugin->getEngine());
         CARLA_SAFE_ASSERT_RETURN(engine != nullptr, 0);
-
+        if (jackbridge_transport_query(engine->fClient, NULL) != JackTransportRolling) return 0; // Don't send anything to audio plugins unless JACK transport is rolling
         if (plugin->tryLock(engine->fFreewheel))
         {
             plugin->initBuffers();
@@ -4562,3 +4562,13 @@ void jack_finish(void *arg)
 
 // -----------------------------------------------------------------------
 #endif // defined(JACKBRIDGE_DIRECT) && !defined(BUILD_BRIDGE)
+
+#include "CarlaHostImpl.hpp"
+
+jack_client_t *determination_get_jack_client(CarlaHostHandle handle) {
+    return ((CarlaBackend::CarlaEngineJack *)(((CarlaHostStandalone *)handle)->engine))->determination_get_jack_client();
+}
+
+void determination_set_process_callback(CarlaHostHandle handle, JackProcessCallback callback, void *arg) {
+    ((CarlaBackend::CarlaEngineJack *)(((CarlaHostStandalone *)handle)->engine))->determination_set_process_callback(callback, arg);
+}
